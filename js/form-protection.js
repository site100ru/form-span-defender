/**
 * СКРИПТ ЗАЩИТЫ ФОРМ ОТ СПАМА 
 * Поддержка множественных форм на странице
 */

// =============================================================================
// КОНФИГУРАЦИЯ МОДУЛЕЙ (включить/выключить проверки)
// =============================================================================
const VALIDATION_CONFIG = {
    // Для заказчика
    requireAllFields: true,          // Все поля обязательны (кроме города)
    nameOnlyCyrillic: true,          // Имя только кириллицей
    emailOnlyLatin: true,            // Email только латиницей
    phoneSameDigits: true,           // Проверка 6 одинаковых цифр подряд
    phoneSequentialDigits: true,     // Проверка 6 цифр по порядку
    cityOnlyCyrillic: true,          // Город только кириллицей
    phoneRussianOperators: true,     // Только российские операторы
    honeypotName: true,              // Скрытое поле имени (ловушка)

    // Для наших проектов
    phoneFullLength: true,           // Полный номер телефона
    formTimestamp: true              // Проверка времени заполнения
};

// =============================================================================
// СПРАВОЧНИК РОССИЙСКИХ КОДОВ ОПЕРАТОРОВ
// =============================================================================
const RUSSIAN_OPERATOR_CODES = [
    '910', '911', '912', '913', '914', '915', '916', '917', '918', '919',
    '980', '981', '982', '983', '984', '985', '986', '987', '988', '989',
    '920', '921', '922', '923', '924', '925', '926', '927', '928', '929',
    '930', '931', '932', '933', '934', '936', '937', '938', '939',
    '900', '901', '902', '903', '904', '905', '906', '908', '909',
    '950', '951', '952', '953', '954', '955', '956', '957', '958', '959',
    '999',
    '940', '941', '942', '943', '944', '945', '946', '947', '948', '949',
    '960', '961', '962', '963', '964', '965', '966', '967', '968', '969',
    '970', '971', '977', '978', '991', '992', '993', '994', '995', '996', '997'
];

// =============================================================================
// МОДУЛИ ВАЛИДАЦИИ
// =============================================================================

/**
 * Проверяет заполнение обязательных полей формы
 * 
 * Логика работы:
 * 1. Проверяет, включена ли валидация в конфигурации (requireAllFields: true)
 * 2. Если выключена (requireAllFields: false) - не работает модуль 
 * 3. Определяет список обязательных полей: имя (user_name), телефон (tel), email (email)
 * 4. Проходит по каждому обязательному полю и проверяет:
 *    - Существует ли значение в форме
 *    - Не является ли заполенное поле пустой строкой после удаления пробелов
 * 5. Для каждого незаполненного поля добавляет сообщение об ошибке
 */
function validateRequiredFields(formData) {
    if (!VALIDATION_CONFIG.requireAllFields) {
        return { valid: true };
    }

    const errors = [];
    const requiredFields = ['user_name', 'tel', 'email'];

    requiredFields.forEach(function (field) {
        if (!formData.get(field) || formData.get(field).trim() === '') {
            errors.push('Поле "' + getFieldLabel(field) + '" обязательно для заполнения');
        }
    });

    return {
        valid: errors.length === 0,
        errors: errors
    };
}

/**
 * Проверяет, что имя написано только кириллицей (русскими буквами)
 *
 * Логика работы:
 * 1. Проверяет, включена ли валидация в конфигурации (nameOnlyCyrillic: true)
 * 2. Если выключена (nameOnlyCyrillic: false) - не работает модуль 
 * 3. Создает регулярное выражение для проверки кириллицы:
 *    - А-Я: заглавные буквы
 *    - а-я: строчные буквы
 *    - Ёё: буква Ё в обоих регистрах
 *    - \s: пробелы
 *    - \-: дефисы (для двойных имен типа "Анна-Мария")
 * 4. Проверяет имя по паттерну
 * 5. Если найдены недопустимые символы (латиница, цифры и т.д.) - возвращает ошибку
 */
function validateNameCyrillic(name) {
    if (!VALIDATION_CONFIG.nameOnlyCyrillic) {
        return { valid: true };
    }

    const cyrillicPattern = /^[А-Яа-яЁё\s\-]+$/;

    if (!cyrillicPattern.test(name)) {
        return {
            valid: false,
            errors: ['Имя должно быть написано только кириллицей (русские буквы)']
        };
    }

    return { valid: true };
}

/**
 * Проверяет корректность email адреса и наличие только латинских символов
 * 
 * Логика работы:
 * 1. Проверяет, включена ли валидация в конфигурации (emailOnlyLatin: true)
 * 2. Если выключена (emailOnlyLatin: false) - не работает модуль 
 * 3. Первая проверка - только латинские символы:
 *    - a-z, A-Z: латинские буквы
 *    - 0-9: цифры
 *    - @._\-: специальные символы для email
 * 4. Если найдена кириллица или другие недопустимые символы - возвращает ошибку
 * 5. Вторая проверка - правильная структура email:
 *    - Символы до @
 *    - Символ @
 *    - Символы после @
 *    - Точка
 *    - Символы после точки (домен)
 * 6. Если структура неверная - возвращает ошибку о некорректном формате
 */
function validateEmailLatin(email) {
    if (!VALIDATION_CONFIG.emailOnlyLatin) {
        return { valid: true };
    }

    const latinPattern = /^[a-zA-Z0-9@._\-]+$/;

    if (!latinPattern.test(email)) {
        return {
            valid: false,
            errors: ['Email должен содержать только латинские буквы']
        };
    }

    const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailPattern.test(email)) {
        return {
            valid: false,
            errors: ['Некорректный формат email']
        };
    }

    return { valid: true };
}

/**
 * Проверяет, что телефон не содержит 6 одинаковых цифр подряд
 * 
 * Логика работы:
 * 1. Проверяет, включена ли валидация в конфигурации (phoneSameDigits: true)
 * 2. Если выключена (phoneSameDigits: false) - не работает модуль
 * 3. Удаляет все нецифровые символы из номера телефона (скобки, дефисы, пробелы и т.д.)
 *    Например: "+7 (999) 111-11-11" -> "79991111111"
 * 4. Создает паттерн для поиска повторяющихся цифр:
 *    - (\d) - захватывает любую цифру в группу
 *    - \1{5} - проверяет, что эта же цифра повторяется еще 5 раз (итого 6 раз)
 * 5. Если найдена последовательность (например, "111111" или "777777") - возвращает ошибку
 *    Защита от спам-ботов, которые часто используют такие номера
 */
function validatePhoneSameDigits(phone) {
    if (!VALIDATION_CONFIG.phoneSameDigits) {
        return { valid: true };
    }

    const digitsOnly = phone.replace(/\D/g, '');
    const sameDigitsPattern = /(\d)\1{5}/;

    if (sameDigitsPattern.test(digitsOnly)) {
        return {
            valid: false,
            errors: ['Телефон не может содержать 6 одинаковых цифр подряд']
        };
    }

    return { valid: true };
}

/**
 * Проверяет, что телефон не содержит 6 последовательных цифр (возрастающих или убывающих)
 * 
 * Логика работы:
 * 1. Проверяет, включена ли валидация в конфигурации (phoneSequentialDigits: true)
 * 2. Если выключена (phoneSequentialDigits: false) - не работает модуль
 * 3. Удаляет все нецифровые символы из номера телефона
 * 4. Проходит по всем возможным 6-значным подстрокам в номере:
 *    - Для номера из 11 цифр будет проверено 6 подстрок
 * 5. Для каждой подстроки проверяет два типа последовательностей:
 *    
 *    A) Возрастающая последовательность (например, "123456"):
 *       - Проходит по 5 парам соседних цифр
 *       - Проверяет, что каждая следующая цифра = предыдущая + 1
 *       - Если хоть одна пара не соответствует - последовательность не возрастающая
 *    
 *    B) Убывающая последовательность (например, "654321"):
 *       - Проходит по 5 парам соседних цифр
 *       - Проверяет, что каждая следующая цифра = предыдущая - 1
 *       - Если хоть одна пара не соответствует - последовательность не убывающая
 * 
 * 6. Если найдена возрастающая ИЛИ убывающая последовательность - возвращает ошибку
 *    Защита от спам-ботов, которые используют простые последовательности
 */
function validatePhoneSequentialDigits(phone) {
    if (!VALIDATION_CONFIG.phoneSequentialDigits) {
        return { valid: true };
    }

    const digitsOnly = phone.replace(/\D/g, '');

    for (let i = 0; i <= digitsOnly.length - 6; i++) {
        const sequence = digitsOnly.substr(i, 6);

        let isAscending = true;
        for (let j = 0; j < 5; j++) {
            if (parseInt(sequence[j + 1]) !== parseInt(sequence[j]) + 1) {
                isAscending = false;
                break;
            }
        }

        let isDescending = true;
        for (let j = 0; j < 5; j++) {
            if (parseInt(sequence[j + 1]) !== parseInt(sequence[j]) - 1) {
                isDescending = false;
                break;
            }
        }

        if (isAscending || isDescending) {
            return {
                valid: false,
                errors: ['Телефон не может содержать 6 цифр подряд по порядку']
            };
        }
    }

    return { valid: true };
}

/**
 * Проверяет, что название города написано только кириллицей
 * 
 * Логика работы:
 * 1. Проверяет, включена ли валидация в конфигурации (cityOnlyCyrillic: true)
 * 2. Если выключена (cityOnlyCyrillic: false) - не работает модуль
 * 3. Проверяет, что поле города не пустое:
 *    - Если city не передан (null/undefined) - пропускает валидацию
 *    - Если city пустая строка после удаления пробелов - пропускает валидацию
 *    Это значит, что поле города НЕ обязательное, но если заполнено - должно быть кириллицей
 * 4. Создает регулярное выражение для проверки кириллицы:
 *    - А-Я: заглавные буквы
 *    - а-я: строчные буквы
 *    - Ёё: буква Ё в обоих регистрах
 *    - \s: пробелы (для городов типа "Нижний Новгород")
 *    - \-: дефисы (для городов типа "Ростов-на-Дону")
 * 5. Проверяет город по паттерну
 * 6. Если найдены недопустимые символы (латиница, цифры) - возвращает ошибку
 */
function validateCityCyrillic(city) {
    if (!VALIDATION_CONFIG.cityOnlyCyrillic || !city || city.trim() === '') {
        return { valid: true };
    }

    const cyrillicPattern = /^[А-Яа-яЁё\s\-]+$/;

    if (!cyrillicPattern.test(city)) {
        return {
            valid: false,
            errors: ['Город должен быть написан только кириллицей']
        };
    }

    return { valid: true };
}

/**
 * Проверяет, что код оператора в номере телефона принадлежит российскому оператору
 * 
 * Логика работы:
 * 1. Проверяет, включена ли валидация в конфигурации (phoneRussianOperators: true)
 * 2. Если выключена (phoneRussianOperators: false) - не работает модуль
 * 3. Удаляет все нецифровые символы из номера телефона
 *    Например: "+7 (999) 111-22-33" -> "79991112233"
 * 4. Извлекает код оператора (3 цифры после первой):
 *    - В российском номере формат: +7 (XXX) YYY-YY-YY
 *    - Первая цифра: 7 или 8 (код страны)
 *    - Цифры с 1 по 3 (индексы): код оператора (например, "999", "916", "903")
 *    - substr(1, 3) извлекает 3 символа начиная с индекса 1
 * 5. Ищет извлеченный код в справочнике RUSSIAN_OPERATOR_CODES. При необходимости нужно добавить в RUSSIAN_OPERATOR_CODES значение оператора
 * 6. Если код не найден в справочнике - возвращает ошибку
 *    Это означает либо иностранный номер, либо несуществующий российский код
 *    Защита от спама с иностранных номеров
 */
function validateRussianOperator(phone) {
    if (!VALIDATION_CONFIG.phoneRussianOperators) {
        return { valid: true };
    }

    const digitsOnly = phone.replace(/\D/g, '');

    const operatorCode = digitsOnly.substr(1, 3);

    if (RUSSIAN_OPERATOR_CODES.indexOf(operatorCode) === -1) {
        return {
            valid: false,
            errors: ['Указан некорректный код российского оператора']
        };
    }

    return { valid: true };
}

/**
 * Проверяет honeypot поле (скрытую ловушку для ботов)
 * 
 * Логика работы:
 * 1. Проверяет, включена ли валидация в конфигурации (honeypotName: true)
 * 2. Если выключена (honeypotName: false) - не работает модуль
 * 3. Получает значение скрытого поля 'name' из формы
 * 4. Логика:
 *    - В HTML форме есть поле <input name="name"> скрытое через CSS (display:none)
 *    - Обычные пользователи его не видят и не заполняют
 *    - Спам-боты видят поле в HTML и автоматически заполняют его
 * 5. Проверяет, заполнено ли honeypot поле:
 *    - Если поле пустое или содержит только пробелы - это реальный пользователь (ОК)
 *    - Если поле заполнено - это бот (блокировка ботов происходит на сервере, это нужно для статистики)
 */
function validateHoneypotName(formData) {
    if (!VALIDATION_CONFIG.honeypotName) {
        return { valid: true };
    }

    const honeypotValue = formData.get('name');
    if (honeypotValue && honeypotValue.trim() !== '') {
        return { valid: true };
    }

    return { valid: true };
}

/**
 * Проверяет, что номер телефона содержит ровно 11 цифр и правильный формат
 * 
 * Логика работы:
 * 1. Проверяет, включена ли валидация в конфигурации (phoneFullLength: true)
 * 2. Если выключена (phoneFullLength: false) - не работает модуль
 * 3. Удаляет все нецифровые символы из номера телефона
 *    Например: "+7 (999) 111-22-33" -> "79991112233"
 * 4. Первая проверка - количество цифр:
 *    - Российский номер должен содержать ровно 11 цифр
 *    - Формат: X XXX XXX-XX-XX (где X - цифра)
 *    - Если цифр меньше или больше 11 - возвращает ошибку
 *    - Примеры корректных: "79991234567", "89991234567" (11 цифр)
 *    - Примеры некорректных: "9991234567" (10 цифр), "379991234567" (12 цифр)
 * 5. Вторая проверка - первая цифра (код страны):
 *    - Российские номера начинаются с 7 (международный формат) или 8 (внутрироссийский)
 *    - digitsOnly[0] - это первая цифра номера
 *    - Если первая цифра не 7 и не 8 - возвращает ошибку
 *    - Примеры корректных: "79991234567", "89991234567"
 *    - Примеры некорректных: "39991234567" (начинается с 3), "19991234567" (начинается с 1)
 * 6. Если обе проверки пройдены - возвращает успешный результат
 */
function validatePhoneFullLength(phone) {
    if (!VALIDATION_CONFIG.phoneFullLength) {
        return { valid: true };
    }

    const digitsOnly = phone.replace(/\D/g, '');

    if (digitsOnly.length !== 11) {
        return {
            valid: false,
            errors: ['Введите полный номер телефона (11 цифр)']
        };
    }

    if (digitsOnly[0] !== '7' && digitsOnly[0] !== '8') {
        return {
            valid: false,
            errors: ['Номер должен начинаться с +7 или 8']
        };
    }

    return { valid: true };
}

/**
 * Проверяет время заполнения формы (защита от ботов)
 * 
 * Логика работы:
 * 1. Проверяет, включена ли валидация в конфигурации (formTimestamp: true)
 * 2. Если выключена (formTimestamp: false) - не работает модуль
 * 3. Получает текущее время отправки формы: Date.now()
 * 4. Преобразует timestamp из строки в число (время открытия формы)
 * 5. Проверяет наличие timestamp:
 *    - Если timestamp пустой или невалидный - возвращает ошибку
 *    - Это может означать, что форма была изменена или отправлена некорректно
 * 6. Вычисляет время заполнения формы в секундах:
 *    - timeSpent = (время_отправки - время_открытия) / 1000
 *    - Делим на 1000, т.к. Date.now() возвращает миллисекунды
 * 7. Минимальная проверка (защита от ботов):
 *    - Если форма заполнена менее чем за 2 секунды - это подозрительно быстро
 *    - Боты обычно заполняют формы мгновенно
 *    - Реальный человек физически не может ввести все данные за 2 секунды
 * 8. Максимальная проверка (защита от устаревших форм):
 *    - Если с момента открытия формы прошло более часа (3600 секунд)
 *    - Также защищает от атак с сохраненными старыми формами
 *    - При обнаружении возвращает ошибку с просьбой обновить страницу
 * 9. Если время заполнения в диапазоне 2 сек - 1 час - возвращает успешный результат
 */
function validateFormTimestamp(timestamp) {
    if (!VALIDATION_CONFIG.formTimestamp) {
        return { valid: true };
    }

    const submitTime = Date.now();
    const formOpenTime = parseInt(timestamp);

    if (!formOpenTime) {
        return {
            valid: false,
            errors: ['Ошибка валидации формы']
        };
    }

    const timeSpent = (submitTime - formOpenTime) / 1000;

    if (timeSpent < 2) {
        return {
            valid: false,
            errors: ['Форма заполнена слишком быстро']
        };
    }

    if (timeSpent > 3600) {
        return {
            valid: false,
            errors: ['Форма устарела, пожалуйста, обновите страницу']
        };
    }

    return { valid: true };
}

// =============================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// =============================================================================

/**
 * Преобразуем поля формы для отправки на почту:
 * 
 * 'user_name' → 'Имя'
 * 'tel' → 'Телефон'
 * 'email' → 'Email'
 * 'city' → 'Город'
 * 
 * Можно добавить любые другие поля, например:
 * 'company' → 'Компания'
 * 'message' → 'Сообщение'
 * 'address' → 'Адрес'
 * 'position' → 'Должность'
 * 
 * Если поле не найдено в справочнике - возвращает исходное имя.
 */
function getFieldLabel(fieldName) {
    const labels = {
        'user_name': 'Имя',
        'tel': 'Телефон',
        'email': 'Email',
        'city': 'Город'
        // Добавьте свои поля здесь:
        // 'company': 'Компания',
        // 'message': 'Сообщение',
    };
    return labels[fieldName] || fieldName;
}

/**
 * Отображает сообщения об ошибках валидации для конкретной формы
 * 
 * Логика работы:
 * 1. Ищет специальный блок для вывода ошибок внутри формы:
 * 
 *  // =============================================================================
 *    - Блок должен иметь класс 'form-errors' 
 *  // =============================================================================
 * 
 *    - Обычно это <div class="form-errors d-none"></div>
 * 2. Если блок найден:
 *    - Объединяет все сообщения об ошибках через <br> (перенос строки в HTML)
 *    - Вставляет HTML с ошибками в блок: errorBlock.innerHTML
 *    - Удаляет класс 'd-none' чтобы показать блок
 * 3. Если блок не найден:
 *    - Показывает стандартный браузерный alert()
 *    - Объединяет ошибки через \n (перенос строки в alert)
 *    - Менее красиво, но работает везде
 */
function showErrorsForForm(form, errors) {
    const errorBlock = form.querySelector('.form-errors');
    if (errorBlock) {
        errorBlock.innerHTML = errors.join('<br>');
        errorBlock.classList.remove('d-none');
    } else {
        alert(errors.join('\n'));
    }
}

/**
 * Скрывает блок с сообщениями об ошибках валидации
 * 
 * Логика работы:
 * 1. Ищет специальный блок для вывода ошибок внутри формы:
 *
 *  // =============================================================================
 *    - Блок должен иметь класс 'form-errors'
 *
 *  // =============================================================================
 *    - Обычно это <div class="form-errors d-none"></div>
 * 2. Если блок найден:
 *    - Добавляет класс 'd-none' для скрытия блока
 *    - Блок остается в DOM, но становится невидимым
 * 3. Если блок не найден:
 *    - Ничего не делает (нет ошибок для скрытия)
 * 4. Используется в двух случаях:
 *    - Перед новой валидацией (чтобы убрать старые ошибки)
 *    - При открытии модального окна с формой (чтобы форма была чистой)
 * 5. Примечание: функция не очищает содержимое блока, только скрывает его
 *    При следующей ошибке старое содержимое будет перезаписано
 */
function hideErrorsForForm(form) {
    const errorBlock = form.querySelector('.form-errors');
    if (errorBlock) {
        errorBlock.classList.add('d-none');
    }
}

// =============================================================================
// ОСНОВНАЯ ФУНКЦИЯ ВАЛИДАЦИИ
// =============================================================================

/**
 * Выполняет полную валидацию формы с использованием всех активных проверок
 * 
 * Логика работы:
 * 1. Создаем пустой для сбора всех ошибок
 * 2. Извлекает значения всех полей формы через formData.get():
 *    - user_name - имя пользователя
 *    - email - электронная почта
 *    - tel - номер телефона
 *    - city - название города
 *    - form_timestamp - метка времени открытия формы
 *    Используем оператор || '' чтобы избежать null/undefined
 * 3. Создает массив всех функций валидации и вызывает каждую:
 *    - validateRequiredFields() - проверка обязательных полей
 *    - validateNameCyrillic() - имя только кириллицей
 *    - validateEmailLatin() - email только латиницей
 *    - validatePhoneSameDigits() - нет 6 одинаковых цифр
 *    - validatePhoneSequentialDigits() - нет 6 последовательных цифр
 *    - validateCityCyrillic() - город только кириллицей
 *    - validateRussianOperator() - российский код оператора
 *    - validateHoneypotName() - проверка honeypot поля
 *    - validatePhoneFullLength() - полная длина телефона
 *    - validateFormTimestamp() - время заполнения формы
 * 4. Проходит по результатам всех валидаций:
 *    - Если валидация не прошла (!result.valid) И есть ошибки (result.errors)
 *    - Добавляет все ошибки из этой валидации в общий массив
 * 5. Возвращает итоговый результат:
 *    - valid: true если массив ошибок пустой (все проверки пройдены)
 *    - errors: массив всех собранных сообщений об ошибках
 * 6. Пример результата при ошибках:
 *    {
 *      valid: false,
 *      errors: ['Поле "Имя" обязательно', 'Email некорректен', 'Телефон слишком короткий']
 *    }
 * 7. Пример результата при успехе:
 *    {
 *      valid: true,
 *      errors: []
 *    }
 */
function validateForm(form) {
    const formData = new FormData(form);
    var allErrors = []; // Используем var вместо const для совместимости

    const userName = formData.get('user_name') || '';
    const email = formData.get('email') || '';
    const tel = formData.get('tel') || '';
    const city = formData.get('city') || '';
    const timestamp = formData.get('form_timestamp') || '';

    const validations = [
        validateRequiredFields(formData),
        validateNameCyrillic(userName),
        validateEmailLatin(email),
        validatePhoneSameDigits(tel),
        validatePhoneSequentialDigits(tel),
        validateCityCyrillic(city),
        validateRussianOperator(tel),
        validateHoneypotName(formData),
        validatePhoneFullLength(tel),
        validateFormTimestamp(timestamp)
    ];

    validations.forEach(function (result) {
        if (!result.valid && result.errors) {
            // Правильное объединение массивов для старых браузеров
            for (var i = 0; i < result.errors.length; i++) {
                allErrors.push(result.errors[i]);
            }
        }
    });

    return {
        valid: allErrors.length === 0,
        errors: allErrors
    };
}

// =============================================================================
// ИНИЦИАЛИЗАЦИЯ
// =============================================================================

/**
 * 
 * Инициализирует защиту форм от спама на всех формах страницы с классом 'protected-form'
 * // =============================================================================
 * У ФОРМЫ ДОЛЖЕН БЫТЬ КЛАСС 'protected-form'
 * // =============================================================================
 * 
 * Логика работы:
 * 1. Находит все формы на странице с классом 'protected-form':
 *    - Использует document.querySelectorAll() для поиска всех подходящих форм
 * 2. Если не найдено ни одной формы:
 *    - Прекращает выполнение (return)
 *    - Не выполняет ненужных действий
 * 3. Для каждой найденной формы выполняет настройку:
 * 
 *    A) ИНИЦИАЛИЗАЦИЯ TIMESTAMP:
 *       - Ищет скрытое поле [name="form_timestamp"] внутри формы
 *       - Если поле найдено - записывает текущее время: Date.now()
 *       - Это время открытия формы, используется для защиты от ботов
 * 
 *    B) ОБРАБОТКА МОДАЛЬНЫХ ОКОН:
 *       - Проверяет, находится ли форма внутри Bootstrap модального окна (.modal)
 *       - Если форма в модалке:
 *         * Добавляет обработчик события 'show.bs.modal' (модалка открывается)
 *         * При открытии модалки:
 *           - Обновляет timestamp (время открытия заново)
 *         * Это нужно, т.к. модалка может открываться многократно
 * 
 *    C) ОБРАБОТКА ОТПРАВКИ ФОРМЫ:
 *       - Добавляет обработчик события 'submit' на форму
 *       - При отправке формы:
 *         1. Отменяет стандартную отправку: e.preventDefault()
 *         2. Скрывает старые ошибки: hideErrorsForForm(form)
 *         3. Выполняет валидацию: validateForm(form)
 *         4. Проверяет результат валидации:
 *            - Если есть ошибки (!validation.valid):
 *              * Показывает ошибки пользователю: showErrorsForForm()
 *              * Прерывает отправку: return false
 *            - Если ошибок нет:
 *              * Отправляет форму: this.submit()
 *              * Форма уйдет на сервер обычным способом
 */
function initFormProtection() {
    const forms = document.querySelectorAll('.protected-form');

    if (forms.length === 0) {
        return;
    }

    forms.forEach(function (form) {
        // Инициализация timestamp при загрузке страницы
        const timestampField = form.querySelector('[name="form_timestamp"]');
        if (timestampField) {
            timestampField.value = Date.now();
        }

        // Обработка модальных окон (если форма внутри модалки)
        const modalParent = form.closest('.modal');
        if (modalParent) {
            modalParent.addEventListener('show.bs.modal', function () {
                if (timestampField) {
                    timestampField.value = Date.now();
                }
                hideErrorsForForm(form);
            });
        }

        // Обработка отправки формы
        form.addEventListener('submit', function (e) {
            e.preventDefault();
            hideErrorsForForm(form);

            const validation = validateForm(form);

            if (!validation.valid) {
                showErrorsForForm(form, validation.errors);
                return false;
            }

            this.submit();
        });
    });
}

/**
 * ЗАПУСК ИНИЦИАЛИЗАЦИИ
 * 
 */
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFormProtection);
} else {
    // DOM уже загружен, запускаем сразу
    initFormProtection();
}