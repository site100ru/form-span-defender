<?php
/**
 * ОБРАБОТЧИК ФОРМЫ С ЗАЩИТОЙ ОТ СПАМА
 * Серверная валидация всех данных
 * Логирование попыток отправки
 */

// Запускаем сессию
session_start();

// =============================================================================
// КОНФИГУРАЦИЯ
// =============================================================================
// Основные настройки обработчика формы
// Здесь можно изменить email получателя, тему письма и включить/выключить проверки
$config = [
    // Email для получения писем с формы
    // ВСТАВЬТЕ СЮДА ВАШ EMAIL:
    'recipient_email' => 'sidorov-vv3@mail.ru',

    // Тема письма, которое придет вам на почту
    // ИЗМЕНИТЕ ТЕМУ ПРИ НЕОБХОДИМОСТИ:
    'email_subject' => 'Заявка на обратный звонок',

    // Путь к файлу логов (записываются все попытки отправки)
    // __DIR__ - это текущая директория, где лежит этот PHP файл
    'log_file' => __DIR__ . '/spam_log.txt',

    // Модули валидации (включить/выключить)
    // true - проверка работает, false - проверка отключена
    'validation' => [
        'require_all_fields' => true,        // Все обязательные поля должны быть заполнены
        'name_only_cyrillic' => true,        // Имя только русскими буквами
        'email_only_latin' => true,          // Email только латинскими буквами
        'phone_same_digits' => true,         // Запрет 6 одинаковых цифр подряд (777777)
        'phone_sequential_digits' => true,   // Запрет 6 последовательных цифр (123456)
        'city_only_cyrillic' => true,        // Город только русскими буквами
        'phone_russian_operators' => true,   // Только российские коды операторов
        'honeypot_name' => true,             // Скрытое поле-ловушка для ботов
        'phone_full_length' => true,         // Полный номер телефона (11 цифр)
        'form_timestamp' => true             // Проверка времени заполнения
    ]
];

// =============================================================================
// СПРАВОЧНИК РОССИЙСКИХ КОДОВ ОПЕРАТОРОВ
// =============================================================================
// Если появились новые коды - добавьте их в этот массив
$russian_operator_codes = [
    '910',
    '911',
    '912',
    '913',
    '914',
    '915',
    '916',
    '917',
    '918',
    '919',
    '980',
    '981',
    '982',
    '983',
    '984',
    '985',
    '986',
    '987',
    '988',
    '989',
    '920',
    '921',
    '922',
    '923',
    '924',
    '925',
    '926',
    '927',
    '928',
    '929',
    '930',
    '931',
    '932',
    '933',
    '934',
    '936',
    '937',
    '938',
    '939',
    '900',
    '901',
    '902',
    '903',
    '904',
    '905',
    '906',
    '908',
    '909',
    '950',
    '951',
    '952',
    '953',
    '954',
    '955',
    '956',
    '957',
    '958',
    '959',
    '999',
    '940',
    '941',
    '942',
    '943',
    '944',
    '945',
    '946',
    '947',
    '948',
    '949',
    '960',
    '961',
    '962',
    '963',
    '964',
    '965',
    '966',
    '967',
    '968',
    '969',
    '970',
    '971',
    '977',
    '978',
    '991',
    '992',
    '993',
    '994',
    '995',
    '996',
    '997'
];

// =============================================================================
// КЛАСС ДЛЯ РАБОТЫ С ЛОГАМИ
// =============================================================================
/**
 * Класс SpamLogger отвечает за запись всех попыток отправки формы в файл
 * 
 * Логика работы:
 * 1. При создании объекта сохраняет путь к файлу логов
 * 2. Метод logAttempt записывает информацию о каждой попытке отправки:
 *    - Дата и время попытки
 *    - IP адрес отправителя
 *    - User Agent (браузер и ОС)
 *    - Флаг спама (true/false)
 *    - Список ошибок валидации (если есть)
 *    - Все данные формы
 * 3. Формирует JSON строку с информацией
 * 4. Записывает в файл с блокировкой (LOCK_EX) для безопасности при одновременных запросах
 * 5. Каждая запись добавляется в конец файла (FILE_APPEND)
 */
class SpamLogger
{
    private $logFile;

    public function __construct($logFile)
    {
        $this->logFile = $logFile;
    }

    /**
     * Записывает попытку отправки формы в лог
     * 
     */
    public function logAttempt($data, $isSpam = false, $errors = [])
    {
        $logEntry = [
            'timestamp' => date('Y-m-d H:i:s'),                       // Текущая дата и время
            'ip' => $_SERVER['REMOTE_ADDR'] ?? 'unknown',             // IP адрес отправителя
            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown', // Браузер и ОС
            'is_spam' => $isSpam,                                     // Флаг спама
            'errors' => $errors,                                      // Ошибки валидации
            'data' => $data                                           // Данные формы
        ];

        // Преобразуем в JSON и записываем в файл
        // JSON_UNESCAPED_UNICODE - сохраняет кириллицу читаемой
        // PHP_EOL - перенос строки (работает на любой ОС)
        // FILE_APPEND - добавляем в конец файла
        // LOCK_EX - блокируем файл на время записи
        $logLine = json_encode($logEntry, JSON_UNESCAPED_UNICODE) . PHP_EOL;
        file_put_contents($this->logFile, $logLine, FILE_APPEND | LOCK_EX);
    }
}

// =============================================================================
// МОДУЛИ ВАЛИДАЦИИ
// =============================================================================
/**
 * Проверяет заполнение обязательных полей формы
 * 
 * Логика работы:
 * 1. Проверяет, включена ли эта валидация в конфигурации
 * 2. Если выключена - пропускает проверку
 * 3. Определяет список обязательных полей: user_name, tel, email
 * 4. Проходит по каждому полю и проверяет:
 *    - Существует ли значение в массиве $data
 *    - Не является ли значение пустой строкой после удаления пробелов
 * 5. Для каждого незаполненного поля добавляет ошибку в массив
 */
function validateRequiredFields($data, $config)
{
    // Если проверка отключена - пропускаем
    if (!$config['validation']['require_all_fields']) {
        return ['valid' => true];
    }

    $errors = [];

    // Список обязательных полей (город не обязателен)
    $requiredFields = ['user_name', 'tel', 'email'];

    foreach ($requiredFields as $field) {
        if (!isset($data[$field]) || trim($data[$field]) === '') {
            $errors[] = "Поле '$field' обязательно для заполнения";
        }
    }

    return [
        'valid' => count($errors) === 0,
        'errors' => $errors
    ];
}

/**
 * Проверяет, что имя написано только кириллицей (русскими буквами)
 * 
 * Логика работы:
 * 1. Проверяет, включена ли эта валидация в конфигурации
 * 2. Если выключена - пропускает проверку
 * 3. Создает регулярное выражение для кириллицы:
 *    - А-Я: заглавные русские буквы
 *    - а-я: строчные русские буквы
 *    - Ёё: буква Ё в обоих регистрах
 *    - \s: пробелы
 *    - \-: дефис (для двойных имен: Анна-Мария)
 * 4. Проверяет имя по этому паттерну
 * 5. Если найдены латинские буквы, цифры или спецсимволы - возвращает ошибку
 */
function validateNameCyrillic($name, $config)
{
    if (!$config['validation']['name_only_cyrillic']) {
        return ['valid' => true];
    }

    // Проверяем, что только кириллица, пробелы и дефисы
    if (!preg_match('/^[А-Яа-яЁё\s\-]+$/u', $name)) {
        return [
            'valid' => false,
            'errors' => ['Имя должно быть написано только кириллицей']
        ];
    }

    return ['valid' => true];
}

/**
 * Проверяет корректность email и наличие только латинских символов
 * 
 * Логика работы:
 * 1. Проверяет, включена ли эта валидация в конфигурации
 * 2. Если выключена - пропускает проверку
 * 3. Первая проверка - только латинские символы:
 *    - a-z, A-Z: латинские буквы
 *    - 0-9: цифры
 *    - @._\-: разрешенные спецсимволы для email
 * 4. Если найдена кириллица или другие символы - ошибка
 * 5. Вторая проверка - встроенная функция PHP filter_var():
 *    - Проверяет правильную структуру email
 *    - Должен быть символ @
 *    - Должен быть домен с точкой
 */
function validateEmailLatin($email, $config)
{
    if (!$config['validation']['email_only_latin']) {
        return ['valid' => true];
    }

    // Проверяем, что только латиница и разрешенные символы
    if (!preg_match('/^[a-zA-Z0-9@._\-]+$/', $email)) {
        return [
            'valid' => false,
            'errors' => ['Email должен содержать только латинские буквы']
        ];
    }

    // Проверяем корректность структуры email встроенной функцией PHP
    if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
        return [
            'valid' => false,
            'errors' => ['Некорректный формат email']
        ];
    }

    return ['valid' => true];
}

/**
 * Проверяет, что телефон не содержит 6 одинаковых цифр подряд
 * 
 * Логика работы:
 * 1. Проверяет, включена ли эта валидация в конфигурации
 * 2. Если выключена - пропускает проверку
 * 3. Удаляет все нецифровые символы из номера:
 *    - Убирает: +, (, ), -, пробелы и т.д.
 *    - Оставляет только цифры
 *    - Пример: "+7 (999) 111-11-11" → "79991111111"
 * 4. Создает регулярное выражение для поиска повторов:
 *    - (\d) - захватывает любую цифру в группу
 *    - \1{5} - проверяет, что эта же цифра повторяется еще 5 раз
 *    - Итого: 6 одинаковых цифр подряд
 * 5. Если найдена последовательность типа "111111", "777777" - ошибка
 */
function validatePhoneSameDigits($phone, $config)
{
    if (!$config['validation']['phone_same_digits']) {
        return ['valid' => true];
    }

    // Удаляем все кроме цифр
    $digitsOnly = preg_replace('/\D/', '', $phone);

    // Проверяем на 6 одинаковых цифр подряд
    if (preg_match('/(\d)\1{5}/', $digitsOnly)) {
        return [
            'valid' => false,
            'errors' => ['Телефон не может содержать 6 одинаковых цифр подряд']
        ];
    }

    return ['valid' => true];
}

/**
 * Проверяет, что телефон не содержит 6 последовательных цифр
 * 
 * Логика работы:
 * 1. Проверяет, включена ли эта валидация в конфигурации
 * 2. Если выключена - пропускает проверку
 * 3. Удаляет все нецифровые символы из номера
 * 4. Проходит по всем возможным 6-значным подстрокам:
 *    - Для 11-значного номера будет 6 подстрок
 *    - Проверяет каждую подстроку на последовательность
 * 5. Для каждой подстроки проверяет два типа последовательностей:
 * 
 *    A) Возрастающая (123456, 234567):
 *       - Каждая следующая цифра = предыдущая + 1
 *       - Проходит по 5 парам соседних цифр
 * 
 *    B) Убывающая (654321, 543210):
 *       - Каждая следующая цифра = предыдущая - 1
 *       - Проходит по 5 парам соседних цифр
 * 
 * 6. Если найдена любая последовательность - ошибка
 */
function validatePhoneSequentialDigits($phone, $config)
{
    if (!$config['validation']['phone_sequential_digits']) {
        return ['valid' => true];
    }

    $digitsOnly = preg_replace('/\D/', '', $phone);
    $len = strlen($digitsOnly);

    // Проверяем все возможные 6-значные подстроки
    for ($i = 0; $i <= $len - 6; $i++) {
        $sequence = substr($digitsOnly, $i, 6);

        // Проверка на возрастающую последовательность (123456)
        $isAscending = true;
        for ($j = 0; $j < 5; $j++) {
            if (intval($sequence[$j + 1]) !== intval($sequence[$j]) + 1) {
                $isAscending = false;
                break;
            }
        }

        // Проверка на убывающую последовательность (654321)
        $isDescending = true;
        for ($j = 0; $j < 5; $j++) {
            if (intval($sequence[$j + 1]) !== intval($sequence[$j]) - 1) {
                $isDescending = false;
                break;
            }
        }

        // Если нашли последовательность - ошибка
        if ($isAscending || $isDescending) {
            return [
                'valid' => false,
                'errors' => ['Телефон не может содержать 6 цифр подряд по порядку']
            ];
        }
    }

    return ['valid' => true];
}

/**
 * Проверяет, что название города написано только кириллицей
 * 
 * Логика работы:
 * 1. Проверяет, включена ли эта валидация в конфигурации
 * 2. Если выключена - пропускает проверку
 * 3. Проверяет, что поле города не пустое:
 *    - Если city пустой - пропускает валидацию
 *    - Это означает, что поле НЕ обязательное
 *    - Но если заполнено - должно быть правильным
 * 4. Создает регулярное выражение для кириллицы:
 *    - А-Я, а-я: русские буквы
 *    - Ёё: буква Ё
 *    - \s: пробелы (для "Нижний Новгород")
 *    - \-: дефис (для "Ростов-на-Дону")
 * 5. Если найдены латинские буквы или цифры - ошибка
 */
function validateCityCyrillic($city, $config)
{
    // Поле необязательное, проверяем только если заполнено
    if (!$config['validation']['city_only_cyrillic'] || empty(trim($city))) {
        return ['valid' => true];
    }

    // Проверяем, что только кириллица, пробелы и дефисы
    if (!preg_match('/^[А-Яа-яЁё\s\-]+$/u', $city)) {
        return [
            'valid' => false,
            'errors' => ['Город должен быть написан только кириллицей']
        ];
    }

    return ['valid' => true];
}

/**
 * Проверяет, что код оператора принадлежит российскому оператору
 * 
 * Логика работы:
 * 1. Проверяет, включена ли эта валидация в конфигурации
 * 2. Если выключена - пропускает проверку
 * 3. Удаляет все нецифровые символы из номера
 * 4. Проверяет длину номера:
 *    - Если не 11 цифр - пропускает проверку
 *    - Код оператора имеет смысл только для полных номеров
 * 5. Извлекает код оператора:
 *    - Формат российского номера: +7 (XXX) YYY-YY-YY
 *    - Первая цифра: 7 или 8 (код страны)
 *    - Цифры 1-3: код оператора (999, 916, 903 и т.д.)
 *    - substr(1, 3) извлекает 3 символа начиная с позиции 1
 * 6. Ищет код в справочнике $operatorCodes
 * 7. Если код не найден - это либо иностранный номер, либо несуществующий код
 */
function validateRussianOperator($phone, $config, $operatorCodes)
{
    if (!$config['validation']['phone_russian_operators']) {
        return ['valid' => true];
    }

    $digitsOnly = preg_replace('/\D/', '', $phone);

    // Проверяем только для 11-значных номеров
    if (strlen($digitsOnly) !== 11) {
        return ['valid' => true];
    }

    // Извлекаем код оператора (3 цифры после первой)
    $operatorCode = substr($digitsOnly, 1, 3);

    // Проверяем наличие в справочнике российских кодов
    if (!in_array($operatorCode, $operatorCodes)) {
        return [
            'valid' => false,
            'errors' => ['Указан некорректный код российского оператора']
        ];
    }

    return ['valid' => true];
}

/**
 * Проверяет honeypot поле (скрытую ловушку для ботов)
 * 
 * Логика работы:
 * 1. Проверяет, включена ли эта валидация в конфигурации
 * 2. Если выключена - пропускает проверку
 * 3. Получает значение скрытого поля 'name' из формы
 * 4. Принцип работы honeypot:
 *    - В HTML есть поле <input name="name"> скрытое через CSS (display:none)
 *    - Обычные пользователи его не видят и не заполняют
 *    - Спам-боты видят поле в HTML и автоматически заполняют
 * 5. Проверяет honeypot поле:
 *    - Если поле пустое - это реальный пользователь (ОК)
 *    - Если поле заполнено - это бот (БЛОКИРУЕМ)
 * 6. На серверной стороне блокировка происходит в основном коде
 * 7. Эта функция нужна для логирования подозрительной активности
 * 
 * Важно: В форме должно быть два поля для имени:
 * - <input name="user_name"> - видимое, для реальных пользователей
 * - <input name="name" style="display:none"> - скрытое, для ловли ботов
 */
function validateHoneypotName($data, $config)
{
    if (!$config['validation']['honeypot_name']) {
        return ['valid' => true];
    }

    // Проверяем скрытое поле name - если оно заполнено, это бот
    if (isset($data['name']) && trim($data['name']) !== '') {
        return [
            'valid' => false,
            'errors' => ['Обнаружена подозрительная активность (honeypot name)']
        ];
    }

    return ['valid' => true];
}

/**
 * Проверяет, что номер телефона содержит ровно 11 цифр
 * 
 * Логика работы:
 * 1. Проверяет, включена ли эта валидация в конфигурации
 * 2. Если выключена - пропускает проверку
 * 3. Удаляет все нецифровые символы из номера
 * 4. Первая проверка - количество цифр:
 *    - Российский номер должен иметь ровно 11 цифр
 *    - Формат: X XXX XXX-XX-XX
 *    - Если цифр меньше или больше - ошибка
 * 5. Вторая проверка - первая цифра (код страны):
 *    - Российские номера начинаются с 7 (международный) или 8 (внутрироссийский)
 *    - Если первая цифра другая - ошибка
 */
function validatePhoneFullLength($phone, $config)
{
    if (!$config['validation']['phone_full_length']) {
        return ['valid' => true];
    }

    $digitsOnly = preg_replace('/\D/', '', $phone);

    // Проверяем количество цифр
    if (strlen($digitsOnly) !== 11) {
        return [
            'valid' => false,
            'errors' => ['Введите полный номер телефона (11 цифр)']
        ];
    }

    // Проверяем первую цифру (должна быть 7 или 8)
    if ($digitsOnly[0] !== '7' && $digitsOnly[0] !== '8') {
        return [
            'valid' => false,
            'errors' => ['Номер должен начинаться с +7 или 8']
        ];
    }

    return ['valid' => true];
}

/**
 * Проверяет время заполнения формы (защита от ботов)
 * 
 * Логика работы:
 * 1. Проверяет, включена ли эта валидация в конфигурации
 * 2. Если выключена - пропускает проверку
 * 3. Получает timestamp из скрытого поля формы
 * 4. Проверяет наличие timestamp:
 *    - Если пустой или невалидный - ошибка
 *    - Форма могла быть изменена или отправлена некорректно
 * 5. Вычисляет время заполнения формы:
 *    - Получает текущее время: time()
 *    - Преобразует timestamp из миллисекунд в секунды: / 1000
 *    - Вычисляет разницу: текущее_время - время_открытия
 * 6. Минимальная проверка (защита от ботов):
 *    - Если форма заполнена менее чем за 2 секунды - подозрительно быстро
 *    - Боты заполняют формы мгновенно
 *    - Человек физически не может заполнить все поля за 2 секунды
 * 7. Максимальная проверка (защита от устаревших форм):
 *    - Если прошло более часа (3600 секунд) - форма устарела
 *    - Защита от атак с сохраненными старыми формами
 * 8. Если время в диапазоне 2 сек - 1 час - успешный результат
 * 
 * Примеры:
 * - 1 секунда ✗ (слишком быстро - бот)
 * - 5 секунд ✓
 * - 30 минут ✓
 * - 2 часа ✗ (форма устарела)
 */
function validateFormTimestamp($timestamp, $config)
{
    if (!$config['validation']['form_timestamp']) {
        return ['valid' => true];
    }

    // Проверяем наличие timestamp
    if (empty($timestamp)) {
        return [
            'valid' => false,
            'errors' => ['Ошибка валидации формы (timestamp)']
        ];
    }

    // Получаем текущее время
    $submitTime = time();
    $formOpenTime = intval($timestamp) / 1000;
    $timeSpent = $submitTime - $formOpenTime;

    // Проверка минимального времени (защита от ботов). Можно уменьшить или увеличить время в секундах.
    if ($timeSpent < 2) {
        return [
            'valid' => false,
            'errors' => ['Форма заполнена слишком быстро']
        ];
    }

    // Проверка максимального времени (защита от устаревших форм). Можно уменьшить или увеличить время в секундах.
    if ($timeSpent > 3600) {
        return [
            'valid' => false,
            'errors' => ['Форма устарела']
        ];
    }

    return ['valid' => true];
}

// =============================================================================
// ГЛАВНАЯ ФУНКЦИЯ ВАЛИДАЦИИ
// =============================================================================
/**
 * Выполняет полную валидацию формы со всеми проверками
 * 
 * Логика работы:
 * 1. Создает пустой массив для сбора всех ошибок
 * 2. Извлекает значения всех полей из массива $data:
 *    - user_name - имя пользователя
 *    - email - электронная почта
 *    - tel - номер телефона
 *    - city - название города
 *    - timestamp - метка времени открытия формы
 * 3. Создает массив всех функций валидации и вызывает каждую:
 *    - validateRequiredFields() - проверка обязательных полей
 *    - validateNameCyrillic() - имя только кириллицей
 *    - validateEmailLatin() - email только латиницей
 *    - validatePhoneSameDigits() - нет 6 одинаковых цифр
 *    - validatePhoneSequentialDigits() - нет 6 последовательных цифр
 *    - validateCityCyrillic() - город только кириллицей
 *    - validateRussianOperator() - российский код оператора
 *    - validateHoneypotName() - проверка honeypot поля
 *    - validatePhoneFullLength() - полная длина телефона
 *    - validateFormTimestamp() - время заполнения формы
 * 4. Проходит по результатам всех валидаций:
 *    - Если валидация не прошла (!$result['valid']) И есть ошибки
 *    - Добавляет ошибки в общий массив через array_merge()
 * 5. Возвращает итоговый результат:
 *    - valid: true если массив ошибок пустой
 *    - errors: массив всех собранных ошибок
 */
function validateFormData($data, $config, $operatorCodes)
{
    $allErrors = [];

    // Извлекаем значения полей
    $userName = $data['user_name'] ?? '';
    $email = $data['email'] ?? '';
    $tel = $data['tel'] ?? '';
    $city = $data['city'] ?? '';
    $timestamp = $data['form_timestamp'] ?? '';

    // Массив всех валидаций
    $validations = [
        // $data - весь массив $_POST, $config - настройки
        validateRequiredFields($data, $config),

        // $userName - имя из user_name, $config - настройки
        validateNameCyrillic($userName, $config),

        // $email - email из email, $config - настройки
        validateEmailLatin($email, $config),

        // $tel - телефон из tel, $config - настройки
        validatePhoneSameDigits($tel, $config),

        // $tel - телефон из tel, $config - настройки
        validatePhoneSequentialDigits($tel, $config),

        // $city - город из city, $config - настройки
        validateCityCyrillic($city, $config),

        // $tel - телефон из tel, $config - настройки, $operatorCodes - справочник кодов
        validateRussianOperator($tel, $config, $operatorCodes),

        // $data - весь массив $_POST (для проверки скрытого поля name), $config - настройки
        validateHoneypotName($data, $config),

        // $tel - телефон из tel, $config - настройки
        validatePhoneFullLength($tel, $config),

        // $timestamp - время из form_timestamp, $config - настройки
        validateFormTimestamp($timestamp, $config)
    ];


    // Собираем все ошибки
    foreach ($validations as $result) {
        if (!$result['valid'] && isset($result['errors'])) {
            $allErrors = array_merge($allErrors, $result['errors']);
        }
    }

    return [
        'valid' => count($allErrors) === 0,
        'errors' => $allErrors
    ];
}

// =============================================================================
// ОТПРАВКА EMAIL
// =============================================================================
/**
 * Отправляет email с данными формы на указанный адрес
 * 
 * Логика работы:
 * 1. Получает адрес получателя и тему из конфигурации
 * 2. Формирует текст письма:
 *    - Заголовок "Новая заявка на обратный звонок"
 *    - Имя пользователя
 *    - Телефон 
 *    - Email
 *    - Город
 *    - IP адрес отправителя
 *    - Дата и время отправки
 * 3. htmlspecialchars() защищает от XSS атак:
 *    - Преобразует < > " ' & в HTML-сущности
 *    - Предотвращает выполнение вредоносного кода
 * 4. Формирует заголовки письма:
 *    - From: адрес отправителя (noreply@ваш-домен)
 *    - Reply-To: email пользователя (чтобы можно было ответить)
 *    - Content-Type: кодировка UTF-8 для кириллицы
 */
function sendEmail($data, $config)
{
    $to = $config['recipient_email'];
    $subject = $config['email_subject'];

    // Формируем текст письма
    $message = "Новая заявка на обратный звонок\n\n";
    $message .= "Имя: " . htmlspecialchars($data['user_name']) . "\n";
    $message .= "Телефон: " . htmlspecialchars($data['tel']) . "\n";
    $message .= "Email: " . htmlspecialchars($data['email']) . "\n";

    // Добавляем город, если заполнен
    if (!empty($data['city'])) {
        $message .= "Город: " . htmlspecialchars($data['city']) . "\n";
    }

    // Добавляем служебную информацию
    $message .= "\n---\n";
    $message .= "IP: " . ($_SERVER['REMOTE_ADDR'] ?? 'unknown') . "\n";
    $message .= "Дата: " . date('Y-m-d H:i:s') . "\n";

    // Формируем заголовки письма
    $headers = "From: noreply@" . $_SERVER['HTTP_HOST'] . "\r\n";
    $headers .= "Reply-To: " . htmlspecialchars($data['email']) . "\r\n";
    $headers .= "Content-Type: text/plain; charset=UTF-8\r\n";

    // Отправляем письмо
    return mail($to, $subject, $message, $headers);
}

// =============================================================================
// ОСНОВНОЙ КОД ОБРАБОТКИ
// =============================================================================

// Проверяем метод запроса
if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405);
    die('Method not allowed');
}

// Создаем объект логгера
$logger = new SpamLogger($config['log_file']);

// Получаем данные формы
$formData = [
    'user_name' => $_POST['user_name'] ?? '',
    'tel' => $_POST['tel'] ?? '',
    'email' => $_POST['email'] ?? '',
    'city' => $_POST['city'] ?? '',
    'name' => $_POST['name'] ?? '',
    'form_timestamp' => $_POST['form_timestamp'] ?? ''
];

// Валидация
$validation = validateFormData($formData, $config, $russian_operator_codes);

if (!$validation['valid']) {
    // Логируем спам
    $logger->logAttempt($formData, true, $validation['errors']);

    // Сохраняем ошибки в сессию
    $_SESSION['win'] = 'block';
    $_SESSION['recaptcha'] = '<p class="text-danger"><strong>Ошибка валидации формы:</strong><br>' . implode('<br>', $validation['errors']) . '</p>';

    header('Location: ' . $_SERVER['HTTP_REFERER']);
    exit;
}

// Отправляем email
$emailSent = sendEmail($formData, $config);

if ($emailSent) {
    // Логируем успешную отправку
    $logger->logAttempt($formData, false, []);

    $_SESSION['win'] = 'block';
    $_SESSION['recaptcha'] = '<p>Спасибо! Ваша заявка успешно отправлена.</p>';

    header('Location: ' . $_SERVER['HTTP_REFERER']);
    exit;
} else {
    // Ошибка отправки
    $_SESSION['win'] = 'block';
    $_SESSION['recaptcha'] = '<p>Ошибка отправки письма. Пожалуйста, попробуйте позже или свяжитесь с нами по телефону.</p>';

    header('Location: ' . $_SERVER['HTTP_REFERER']);
    exit;
}
